; AutoExp.Dat - templates for automatically expanding data
; Copyright(c) Microsoft Corporation. All Rights Reserved.
;---------------------------------------------------------------
;
; While debugging, Data Tips and items in the Watch and Variable
; windows are automatically expanded to show their most important
; elements. The expansion follows the format given by the rules
; in this file. You can add rules for your types or change the
; predefined rules.
;
; For good examples, read the rules in this file.
;
; To find what the debugger considers the type of a variable to
; be, add it to the Watch window and look at the Type column.
;
; An AutoExpand rule is a line with the name of a type, an equals 
; sign, and text with replaceable parts in angle brackets. The 
; part in angle brackets names a member of the type and an 
; optional Watch format specifier.
;
; AutoExpand rules use the following syntax. The equals sign (=), 
; angle brackets (<>), and comma are taken literally. Square
; brackets ([]) indicate optional items.
;
; type=[text]<member[,format]>...
;
; type      Name of the type (may be followed by <*> for template
;           types such as the ATL types listed below).
;
; text      Any text.Usually the name of the member to display, 
;           or a shorthand name for the member.
;
; member    Name of a member to display.
;
; format    Watch format specifier. One of the following:
;
;   Letter  Description                 Sample         Display
;   ------  --------------------------  ------------   -------------
;   d,i     Signed decimal integer      0xF000F065,d   -268373915
;   u       Unsigned decimal integer    0x0065,u       101
;   o       Unsigned octal integer      0xF065,o       0170145
;   x,X     Hexadecimal integer         61541,X        0X0000F065
;   l,h     long or short prefix for    00406042,hx    0x0c22
;             d, i, u, o, x, X
;   f       Signed floating-point       3./2.,f        1.500000
;   e       Signed scientific-notation  3./2.,e        1.500000e+000
;   g       Shorter of e and f          3./2.,g        1.5
;   c       Single character            0x0065,c       'e'
;   s       Zero-terminated string      pVar,s         "Hello world"
;   su      Unicode string              pVar,su        "Hello world"
;
; For details of other format specifiers see Help under:
; "format specifiers/watch variable"
;
; The special format <,t> specifies the name of the most-derived 
; type of the object. This is especially useful with pointers or
; references to a base class.
;
; If there is no rule for a class, the base classes are checked for
; a matching rule.
;
; There are some special entries allowed in the AutoExpand section:
; $BUILTIN is used to display more complex types that need to do more
; than just show a member variable or two.
; $ADDIN allows external DLLs to be added to display even more complex
; types via the EE Add-in API. The first argument is the DLL name, the
; second argument is the name of the export from the DLL to use. For 
; further information on this API see the sample called EEAddIn.
;
; WARNING: if hexadecimal mode is on in the watch window, all numbers here are
; evaluated in hex, e.g. 42 becomes 0x42

[AutoExpand]

; from windef.h
tagPOINT =x=<x> y=<y>
tagRECT =top=<top> bottom=<bottom> left=<left> right=<right>

; from winuser.h
tagMSG =msg=<message,x> wp=<wParam,x> lp=<lParam,x>

; intrinsics
__m64 =<m64_i64,x>
__m128=$BUILTIN(M128)
__m128i=$BUILTIN(M128I)
__m128d=$BUILTIN(M128D)

; from afxwin.h
CDC =hDC=<m_hDC> attrib=<m_hAttribDC>
CPaintDC =<,t> hWnd=<m_hWnd>
CPoint =x=<x> y=<y>
CRect =top=<top> bottom=<bottom> left=<left> right=<right>
CSize =cx=<cx> cy=<cy>
CWnd =<,t> hWnd=<m_hWnd>
CWinApp =<,t> <m_pszAppName,s>
CWinThread =<,t> h=<m_hThread> proc=<m_pfnThreadProc>

; from afxcoll.h
CPtrList =cnt=<m_nCount>

; from afxstat_.h
CProcessLocalObject =<,t>
CThreadLocalObject =<,t>

; from afx.h
CArchiveException =cause=<m_cause>
CFile =hFile=<m_hFile> name=<m_strFileName.m_pchData,s>
CFileException =cause=<m_cause> OS Error=m_lOsError
CMemFile =pos=<m_nPosition> size=<m_nFileSize>
CObject =<,t>
CRuntimeClass =<m_lpszClassName,s>
CStdioFile =FILE*=<m_pStream> name=<m_strFilename.m_pchData,s>
CTimeSpan =time=<m_time>
CTime =time=<m_time>

; from afxcoll.h
CByteArray =count=<m_nCount>
CStringList =count=<m_nCount>
; same for all CXXXArray classes
; same for CXXXList
; same for CMapXXToXX

; various string classes from MFC & ATL

_com_error=<m_hresult,hr>
_bstr_t=<m_Data->m_wstr,su> (<m_Data->m_RefCount,u>)
_com_ptr_t<*>=<m_pInterface>
_LARGE_INTEGER=<QuadPart>
_ULARGE_INTEGER=<QuadPart>
ATL::CComPtr<*>=<p>

ATL::CComQIPtr<*>=<p>

tagVARIANT=$BUILTIN(VARIANT)
VARIANT=$BUILTIN(VARIANT)
_GUID=$BUILTIN(GUID)

; see EEAddIn sample for how to use these
;_SYSTEMTIME=$ADDIN(EEAddIn.dll,AddIn_SystemTime)
;_FILETIME=$ADDIN(EEAddIn.dll,AddIn_FileTime)

std::binder1st<*>= op=<op> value=<value>
std::binder2nd<*>= op=<op> value=<value>
std::less<*>=lessthan
std::greater<*>=greaterthan
_D3DBOX=<Left,u>, <Top,u>, <Right,u>, <Bottom,u>, <Front,u>, <Back,u>
_D3DRECT=<x1,u>, <y1,u>, <x2,u>, <y2,u>
_D3DVECTOR=<x,g>, <y,g>, <z,g>
D3DXCOLOR=<r,g>, <g,g>, <b,g>, <a,g>
D3DXPLANE=<a,g>, <b,g>, <c,g>, <d,g>
D3DXQUATERNION=<x,g>, <y,g>, <z,g>, <w,g>
D3DXVECTOR2=<x,g>, <y,g>
D3DVECTOR4=<x,g>, <y,g>, <z,g>, <w,g>

;QT_DEBUG_START (Qt Visual Studio Add-in v1.1.10)

QByteArray=<d->data,s> size=<d->size,u>
QPoint =x=<xp> y=<yp>
QPointF =x=<xp> y=<yp>
QRect =x1=<x1> y1=<y1> x2=<x2> y2=<y2>
QRectF =x=<xp> y=<yp> w=<w> h=<h>
QSize =width=<wd> height=<ht>
QSizeF =width=<wd> height=<ht>
QHash<*> =size=<d->size>
QVarLengthArray<*> =size=<s> data=<ptr>

;QT_DEBUG_END

[Visualizer]
; This section contains visualizers for STL and ATL containers
; DO NOT MODIFY

ATL::CStringT<char,*>|CSimpleStringT<char,*>|ATL::CSimpleStringT<char,*>{
	preview([$c.m_pszData,s])
        stringview([$c.m_pszData,sb])
}

ATL::CStringT<wchar_t,*>|CSimpleStringT<wchar_t,*>|ATL::CSimpleStringT<wchar_t,*>|ATL::CStringT<unsigned short,*>|CSimpleStringT<unsigned short,*>|ATL::CSimpleStringT<unsigned short,*>{
	preview([$c.m_pszData,su])
        stringview([$c.m_pszData,sub])
}

ATL::CComBSTR{
	preview([$c.m_str,su])
        stringview([$c.m_str,sub])
}


;------------------------------------------------------------------------------
;  std::vector<bool,*> specialization
;------------------------------------------------------------------------------

std::vector<bool,*>{
	children
	(
		#array
		(
			expr : ($c._Myvec._Myfirst[$i / _VBITS] >> ($i % _VBITS)), 
			size : ($c._Mysize)
		)  : (bool)($e & 1)
	)
		
    preview
    ( 
            #( 
				"[", 
				$e._Mysize , 
				"](", 
				#array
				(
					expr : ($c._Myvec._Myfirst[$i / _VBITS] >> ($i % _VBITS)), 
					size : ($c._Mysize)
				)  : (bool)($e & 1), ")")
	)		
}

std::vector<bool,*>::iterator|std::vector<bool,*>::const_iterator|std::_Vb_iterator<*>|std::_Vb_const_iterator<*>{
	preview
	(
		#( 
			(bool) (((*$e._Myptr) >> $e._Myoff) & 1)   
		)
	)
	
	children
	(
		#( 
			ptr: (bool) (((*$e._Myptr) >> $e._Myoff) & 1)   
		)
	)

	
}


;------------------------------------------------------------------------------
;  std::vector
;------------------------------------------------------------------------------
std::vector<*>{
	children
	(
	    #array
	    (
			expr :	($c._Myfirst)[$i],  
			size :	$c._Mylast-$c._Myfirst
		)
	)
	
    preview
    ( 
        #( 
			"[", 
            $e._Mylast - $e._Myfirst , 
            "](", 
            
            #array
            (
				expr : 	($c._Myfirst)[$i],  
				size : 	$c._Mylast-$c._Myfirst
			), 
			")"
		)
	)
	

}

std::_Vector_iterator<*>|std::_Vector_const_iterator<*>{
	preview 
	(
		#(*$e._Myptr)
	)
	
	children
	(
		#(ptr: *$e._Myptr)
	)
}



;------------------------------------------------------------------------------
;  std::vectorfix
;------------------------------------------------------------------------------
std::vectorfix<*>{
	children
	(
	    #array
	    (
			expr :	($c._Myfirst)[$i],  
			size :	$c._Mylast-$c._Myfirst
		)
	)
	
    preview
    ( 
        #( 
			"[", 
            $e._Mylast - $e._Myfirst , 
            "](", 
            
            #array
            (
				expr : 	($c._Myfirst)[$i],  
				size : 	$c._Mylast-$c._Myfirst
			), 
			")"
		)
	)
	

}

std::_Vectorfix_iterator<*>|std::_Vectorfix_const_iterator<*>{
	preview 
	(
		#(*$e._Myptr)
	)
	
	children
	(
		#(ptr: *$e._Myptr)
	)
}



;------------------------------------------------------------------------------
;  std::string/basic_string
;------------------------------------------------------------------------------

std::basic_string<char,*>{
	preview
	( 
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			[$e._Bx._Buf,s]
		)
		#else
		(
			[$e._Bx._Ptr,s]
		)
	)
	
	stringview
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			[$e._Bx._Buf,sb]
		)
		#else
		(
			[$e._Bx._Ptr,sb]
		)
	)
	
	children
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			#([actual members]: [$e,!] , #array( expr: $e._Bx._Buf[$i], size: $e._Mysize))
		)
		#else
		(
			#([actual members]: [$e,!],  #array( expr: $e._Bx._Ptr[$i], size: $e._Mysize))
		)	
	)	

}

std::basic_string<unsigned short,*>|std::basic_string<wchar_t,*>{
	preview
	( 
		#if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,su] )
		#else ( [$e._Bx._Ptr,su] )
	)
	
	stringview
	( 
		#if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,sub] )
		#else ( [$e._Bx._Ptr,sub] )
	)
	
	children
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			#([actual members]: [$e,!] , #array( expr: $e._Bx._Buf[$i], size: $e._Mysize))
		)
		#else
		(
			#([actual members]: [$e,!],  #array( expr: $e._Bx._Ptr[$i], size: $e._Mysize))
		)	
	)	
}

std::basic_string<*>::iterator|std::basic_string<*>::const_iterator|std::_String_iterator<*>|std::_String_const_iterator<*>{
	preview
	( 
		#( $e._Myptr ) 
	)

	children
	( 
		#( ptr: $e._Myptr ) 
	)
}

std::pair<*>{
	preview
	(
		#( 
			"(", 
			$e.first, 
			",", 
			$e.second , 
			")"
		)
	)
}

;------------------------------------------------------------------------------
;  std::auto_ptr
;------------------------------------------------------------------------------

std::auto_ptr<*>{
	preview
	( 
		#(	"auto_ptr ",
			(*(($T1 *)$c._Myptr))
		 )
	)
	children
	( 
		#( 
			ptr: (*(($T1 *)$c._Myptr)) 
		)
	)
}

;------------------------------------------------------------------------------
;  std::map
;------------------------------------------------------------------------------

std::map<*>{
	children
	(
		#tree
		(
			head : $c._Myhead->_Parent, 
		    skip : $c._Myhead, 
		    size : $c._Mysize, 
		    left : _Left, 
		    right : _Right
		) : $e._Myval
	)
		     
	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 

			#tree
			(
				head : $c._Myhead->_Parent, 
				skip : $c._Myhead, 
				size : $c._Mysize, 
				left : _Left, 
				right : _Right
			) : $e._Myval,
			
			")"
		)
	)		     
}

;------------------------------------------------------------------------------
;  std::multi_map
;------------------------------------------------------------------------------

std::multimap<*>{
	children
	(
		#tree
		(
			head : $c._Myhead->_Parent, 
		    skip : $c._Myhead, 
		    size : $c._Mysize, 
		    left : _Left, 
		    right : _Right
		) : $e._Myval
	)
		     
	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 
			
			#tree
			(	
				head : $c._Myhead->_Parent, 
				skip : $c._Myhead, 
				size : $c._Mysize, 
				left : _Left, 
				right : _Right
			) : $e._Myval,
			
			")"
		)
	)		     
}


;------------------------------------------------------------------------------
;  std::list
;------------------------------------------------------------------------------

std::list<*>{

	children
	(
		#list
		(
			head : $c._Myhead->_Next, 
		    size : $c._Mysize, 
		    next : _Next
		) : $e._Myval
	)
		          
	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 
		  
			#list
			(
				head : $c._Myhead->_Next, 
				size : $c._Mysize, 
				next : _Next
			) : $e._Myval,
		 
			")"
		)
	)			      
}

std::list<*>::iterator|std::list<*>::const_iterator|std::list<*>::_Iterator<1>|std::list<*>::_Const_iterator<1>{
	preview
	(
		#($e._Ptr->_Myval)
	)
	
	children
	(
		#(ptr: $e._Ptr->_Myval)
	)

}


;------------------------------------------------------------------------------
;  std::bitset  <bitset>
;------------------------------------------------------------------------------

std::bitset<*>{       
	preview
	(
		#(
		"[",
			$c.digits,
		"](",
		#array
		(	
			expr : 	($c._Array[$i / $c._Bitsperword] >> ($i % $c._Bitsperword)),  
			size : 	$c.digits
		) : [($e & 1),d],
		")"
		)
	)
	children
	(
		#array
		(	
			expr : 	($c._Array[$i / $c._Bitsperword] >> ($i % $c._Bitsperword)),  
			size : 	$c.digits
		) : (bool)($e & 1))
}

std::bitset<*>::reference{
    preview
    (
		#(
			"bitset[", $e._Mypos, "] = ", 
			(bool)(($e._Pbitset->_Array[$i / _Bitsperword] >> ($e._Mypos % _Bitsperword)) & 1) 
		)
    )
}

;------------------------------------------------------------------------------
;  std::deque
;------------------------------------------------------------------------------

std::deque<*>{
	children
	(
		#array
		(
			expr : $c._Map[ (($i + $c._Myoff) / $c._EEN_DS) % $c._Mapsize][($i + $c._Myoff) % $c._EEN_DS],  
			size : $c._Mysize
		)
	)

	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 
		  
			#array
			(
				expr : $c._Map[ (($i + $c._Myoff) / $c._EEN_DS) % $c._Mapsize][($i + $c._Myoff) % $c._EEN_DS],  
				size : $c._Mysize
			),
		 
			")"
		)
	)		       
}

std::deque<*,*>::iterator|std::_Deque_iterator<*,*,*>|std::_Deque_const_iterator<*,*,*>{
   preview
   (
	   #if( $e._Myoff >= ((std::deque<$T1,$T2 > *)$c._Mycont)->_Myoff + ((std::deque<$T1,$T2 > *)$c._Mycont)->_Mysize)
	   (
	   		#("<end>")
	   )
	   #else(
			#(
				"deque[", 
				$e._Myoff - ((std::deque<$T1,$T2 > *)$c._Mycont)->_Myoff, 
				"] = ",
				((std::deque<$T1,$T2 > *)$c._Mycont)->_Map[ (($c._Myoff) / ((std::deque<$T1,$T2 > *)$c._Mycont)->_EEN_DS) % ((std::deque<$T1,$T2 > *)$c._Mycont)->_Mapsize][$c._Myoff % ((std::deque<$T1,$T2 > *)$c._Mycont)->_EEN_DS] 
			)
		)
	)
	children
	(
	   #if( ((std::deque<$T1,$T2 > *)$c._Mycont)->_Myoff + ((std::deque<$T1,$T2 > *)$c._Mycont)->_Mysize > $e._Myoff) 
	   (
			#(
				ptr: ((std::deque<$T1,$T2 > *)$c._Mycont)->_Map[ ($c._Myoff / ((std::deque<$T1,$T2 > *)$c._Mycont)->_EEN_DS) % ((std::deque<$T1,$T2 > *)$c._Mycont)->_Mapsize][$c._Myoff % ((std::deque<$T1,$T2 > *)$c._Mycont)->_EEN_DS] 
			)
		)
	)
}

;------------------------------------------------------------------------------
;  std::queue
;------------------------------------------------------------------------------

std::queue<*>{
	children
	(
		#array
		(
			expr : $c.c._Map[ (($i + $c.c._Myoff) / $c.c._EEN_DS) % $c.c._Mapsize][($i + $c.c._Myoff) % $c.c._EEN_DS],  
			size : $c.c._Mysize
		)
	)
		   
 preview
	(
		#(
			"[", 
			$e.c._Mysize, 
			"](", 
		  
			#array
			(
				expr : $c.c._Map[ (($i + $c.c._Myoff) / $c.c._EEN_DS) % $c.c._Mapsize][($i + $c.c._Myoff) % $c.c._EEN_DS],  
				size : $c.c._Mysize
			),
		 
			")"
		)
	)			   
}


;------------------------------------------------------------------------------
;  std::priority_queue
;------------------------------------------------------------------------------

std::priority_queue<*>{
	preview
	( 
		$e.c 
	)
}

;------------------------------------------------------------------------------
;  std::set
;------------------------------------------------------------------------------

std::set<*>{
    preview
    ( 
		#( 
			"[", 
            $e._Mysize , 
            "](", 
            
            #tree
            (
				head : $c._Myhead->_Parent, 
				skip : $c._Myhead, 
				left : _Left, 
				right : _Right,
				size  : $c._Mysize
			) : $e._Myval, 
			
			")"
		)
	)
			   
	children
	(
		#tree
		(
			head : $c._Myhead->_Parent, 
			skip : $c._Myhead, 
			left : _Left, 
			right : _Right,
			size  : $c._Mysize
		) : $e._Myval
	)
}

;------------------------------------------------------------------------------
;  std::multi_set
;------------------------------------------------------------------------------

std::multiset<*>{
    preview
    (
		#( 
			"[", 
            $e._Mysize , 
            "](", 
            
            #tree
            (
				head : $c._Myhead->_Parent, 
				skip : $c._Myhead, 
				left : _Left, 
				right : _Right,
				size  : $c._Mysize
			) : $e._Myval, 
			
			")"
		)
	)
			   
	children
	(
		#tree
		(
			head : $c._Myhead->_Parent, 
			skip : $c._Myhead, 
			left : _Left, 
			right : _Right,
			size  : $c._Mysize
		) : $e._Myval
	)
}


;------------------------------------------------------------------------------
;  std::_Tree (shared my map/multimap/set/multiset)
;------------------------------------------------------------------------------

std::_Tree<*>::iterator|std::_Tree<*>::const_iterator{
	preview
	(
		#($e._Ptr->_Myval)
	)
	
	children
	(
		#(ptr: $e._Ptr->_Myval)
	)

	
}


;------------------------------------------------------------------------------
;  std::stack
;------------------------------------------------------------------------------

std::stack<*>{
	children
	(
		#array
		(
			expr : $c.c._Map[ (($i + $c.c._Myoff) / $c.c._EEN_DS) % $c.c._Mapsize][($i + $c.c._Myoff) % $c.c._EEN_DS],  
			size : $c.c._Mysize
		)
	)
           
    preview
    (
		#( 
			"[", 
            $e.c._Mysize , 
            "](", 
            
            #array
            (
				expr : $c.c._Map[ (($i + $c.c._Myoff) / $c.c._EEN_DS) % $c.c._Mapsize][($i + $c.c._Myoff) % $c.c._EEN_DS],  
				size : $c.c._Mysize
			), 
			
			")"
		)
	)           
}

;------------------------------------------------------------------------------
;  stdext::hash_map
;  stdext::hash_multimap
;  stdext::hash_set
;  stdext::hash_multiset
;------------------------------------------------------------------------------

stdext::hash_map<*>|stdext::hash_multimap<*>|stdext::hash_set<*>|stdext::hash_multiset<*>{
	
	preview
	(
		#(
			"[", 
			$e._List._Mysize, 
			"](", 
		 
			#list
			(
				head : $c._List._Myhead->_Next, 
          	    size : $c._List._Mysize,
				next : _Next
			) : $e._Myval,
			
			")"
		)
	)	

	children
	(
    
		#list
		(
			head : $c._List._Myhead->_Next, 
			size : $c._List._Mysize, 
			next : _Next
		) : $e._Myval
	)
}

;------------------------------------------------------------------------------
;  std::complex
;------------------------------------------------------------------------------

std::complex<*>{
	children
	(
		#(
			real: $e._Val[0],
			imaginary: $e._Val[1]
		)
	)
	preview
	(
		#if($e._Val[1] != 0)
		(										
			#if ($e._Val[0] != 0)				
			(									; Real and Imaginary components 
				#if ($e._Val[1] >= 0)
				(
					#($e._Val[0],"+i*", $e._Val[1])
				)
				#else
				(
					#($e._Val[0],"-i*", -$e._Val[1])							  
				)
			)
			#else
			(									; Purely imaginary
				#if ($e._Val[1] >= 0.0)
				(
					#("i*", $e._Val[1])
				)
				#else
				(
					#("-i*", -$e._Val[1])						
				)
			)
		)
		#else
		(										; Purely real
			$e._Val[0]		
		)
	)
}

;------------------------------------------------------------------------------
;  std::valarray
;------------------------------------------------------------------------------

std::valarray<*>{
    preview
    ( 
		#( 
			"[", 
            $e._Mysize , 
            "](", 
            
            #array
            (
				expr : 	($c._Myptr)[$i],  
				size : 	$c._Mysize
			), 
			
			")"
		)
	)
	
	children
	(
		#array
		(
			expr :	($c._Myptr)[$i],  
			size :	$c._Mysize
		)
	)
}

;------------------------------------------------------------------------------
;  PROPVARIANT
;------------------------------------------------------------------------------

; Visualizers for VT_VECTOR C arrays
tagCAC|tagCAUB|tagCAI|tagCAUI|tagCAL|tagCAUL|tagCAFLT|tagCADBL|tagCACY|tagCADATE|tagCABSTR|tagCABSTRBLOB|tagCABOOL|tagCASCODE|tagCAPROPVARIANT|tagCAH|tagCAUH|tagCALPSTR|tagCALPWSTR|tagCAFILETIME|tagCACLIPDATA|tagCACLSID{
	preview(
		#( 
			"[", 
            $e.cElems , 
            "](", 
            
            #array
            (
				expr : 	($c.pElems)[$i],  
				size : 	$c.cElems
			), 			
			")"
		)
	)

	children
	(
		#array
		(
			expr :	($c.pElems)[$i],  
			size :	$c.cElems
		)
	)	
	
}

; Visualizers for SAFE ARRAY
tagSAFEARRAY|SAFEARRAY{
	preview(		
			#if ($c.fFeatures & 0x0080)		; FADF_HAVEVARTYPE 
			(
				;
				;	Switch on the variant type field - which is stored 4 bytes
				;	before the beginning of the SAFEARRAY type
				;
				#switch( ((unsigned *)&($c))[-1] )						
					#case 0x2							; VT_I2 | VT_ARRAY
					(
						#(
							"safearray of I2 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((signed short *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x3							; VT_I4 | VT_ARRAY
					(
						#(
							"safearray of I4 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((signed int *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x4							; VT_R4 | VT_ARRAY
					(
						#(
							"safearray of R4 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((float *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x5							; VT_R8 | VT_ARRAY
					(
						#(
							"safearray of R8 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((double *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x6							; VT_CY | VT_ARRAY
					(
						#(
							"safearray of CY = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((CY *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)
					
					#case 0x7							; VT_DATE | VT_ARRAY
					(
						#(
							"safearray of DATE = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((DATE *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)		
					
					#case 0x8							; VT_BSTR | VT_ARRAY
					(
						#(
							"safearray of BSTR = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((wchar_t **)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	

					#case 0xa							; VT_ERROR | VT_ARRAY
					(
						#(
							"safearray of ERROR = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((long *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)
					
					#case 0xb							; VT_BOOL | VT_ARRAY
					(
						#(
							"safearray of BOOL = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((short *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)		
					
					#case 0xc							; VT_VARIANT | VT_ARRAY
					(
						#(
							"safearray of VARIANT = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((tagVARIANT *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x10							; VT_I1 | VT_ARRAY
					(
						#(
							"safearray of I1 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((signed char *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)		
					
					#case 0x11							; VT_UI1 | VT_ARRAY
					(
						#(
							"safearray of UI1 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned char *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)		
					
					#case 0x12							; VT_UI2 | VT_ARRAY
					(
						#(
							"safearray of UI2 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned short *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x13							; VT_UI4 | VT_ARRAY
					(
						#(
							"safearray of UI4 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned int *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x14							; VT_I8 | VT_ARRAY
					(
						#(
							"safearray of I8 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((signed __int64 *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x15							; VT_UI8 | VT_ARRAY
					(
						#(
							"safearray of UI8 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned __int64 *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x16							; VT_INT | VT_ARRAY
					(
						#(
							"safearray of INT = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((int *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)																																																																																
					
					#case 0x17							; VT_UINT | VT_ARRAY
					(
						#(
							"safearray of UINT = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x1e							; VT_LPSTR | VT_ARRAY
					(
						#(
							"safearray of LPSTR = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((char **)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	

					#case 0x1f							; VT_LPWSTR | VT_ARRAY
					(
						#(
							"safearray of LPWSTR = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((wchar_t **)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x40							; VT_FILETIME | VT_ARRAY
					(
						#(
							"safearray of FILETIME = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((FILETIME *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x47							; VT_CLIPDATA | VT_ARRAY
					(
						#(
							"safearray of CLIPDATA = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((CLIPDATA *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x48							; VT_CLSID | VT_ARRAY
					(
						#(
							"safearray of CLSID = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((CLSID *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)																															
			)
			#elif ($c.fFeatures & 0x0100)		; FADF_BSTR 
			(
				#("safearray of BSTR = ",#array(expr: $c.rgsabound[$i].cElements, size: $c.cDims) : #("[",$e,"]"), "(", #array(expr: ((wchar_t * *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound ), ")")
			)
			#elif ($c.fFeatures & 0x0200)		; FADF_UNKNOWN
			(
				#("safearray of IUnknown* = ",#array(expr: $c.rgsabound[$i].cElements, size: $c.cDims) : #("[",$e,"]"), "(", #array(expr: ((IUnknown *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound ), ")")
			)	
			#elif ($c.fFeatures & 0x0400)		; FADF_DISPATCH
			(
				#("safearray of IDispatch* = ",#array(expr: $c.rgsabound[$i].cElements, size: $c.cDims) : #("[",$e,"]"), "(", #array(expr: ((IDispatch*)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound ), ")")
			)
			#elif ($c.fFeatures & 0x0800)		; FADF_VARIANT
			(
				#("safearray of VARIANT = ",#array(expr: $c.rgsabound[$i].cElements, size: $c.cDims) : #("[",$e,"]"), "(", #array(expr: ((tagVARIANT *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound ), ")")
			)
	)
	children(
		#(									;[actual members]: [$c,!],
			#if ($c.fFeatures & 0x0080)		; FADF_HAVEVARTYPE 
			(
				#switch( ((unsigned *)&($c))[-1] )	; for some reason the VT field is before the SAFEARRAY struct
					#case 2							; VT_I2|VT_ARRAY
					( 
						#array(
								expr: ((signed short *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							  )
					)				
					
					#case 3							; VT_I4|VT_ARRAY
					( 
						#array(
								expr: ((signed int   *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							   )
					)		
							
					#case 4							; VT_R4|VT_ARRAY
					( 
						#array(
								expr: ((float *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements,
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							   )
					)		
							
					#case 5							; VT_R8|VT_ARRAY
					( 
						#array(
								expr: ((double  *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							  )
					)		
							
					#case 0x10						; VT_I1|VT_ARRAY
					( 
						#array(
								expr: ((signed char *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							   )
					)	
								
					#case 0x11						; VT_UI1|VT_ARRAY
					( 
						#array(
								expr: ((unsigned char *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							  )
					)		
							
					#case 0x12						; VT_UI2|VT_ARRAY
					( 
						#array(
								expr: ((unsigned short *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							   )
					)		
							
					#case 0x13						; VT_UI4|VT_ARRAY
					( 
						#array(
								expr: ((unsigned int *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							   )	
					)
								
					#case 0x14						; VT_I8|VT_ARRAY
					( 
						#array(
								expr: ((signed __int64 *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							   )				
					)							 
					#case 0x15						; VT_UI8|VT_ARRAY
					( 
						#array(
								expr: ((unsigned __int64 *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )				
					)
					
					#case 0x1e						; VT_LPSTR|VT_ARRAY
					( 
						#array(
								expr: ((char * *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0x1f						; VT_LPWSTR|VT_ARRAY
					( 
						#array(
								expr: ((wchar_t **)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )		
					)
					
					#case 0xc						; VT_VARIANT|VT_ARRAY
					( 
						#array(
								expr: ((tagVARIANT *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					
					)
					
					#case 0xb						; VT_BOOL|VT_ARRAY
					(					
						#array(
								expr: ((short *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0xa						; VT_ERROR|VT_ARRAY
					( 
						#array(
								expr: ((long *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 6							; VT_CY|VT_ARRAY
					( 
						#array(
								expr: ((CY *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )				
					)
					
					#case 7							; VT_DATE|VT_ARRAY
					( 
						#array(
								expr: ((DATE *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0x40						; VT_FILETIME|VT_ARRAY
					( 
						#array(
								expr: ((FILETIME *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )		
					)
					
					#case 0x48						; VT_CLSID|VT_ARRAY
					( 
						#array(
								expr: ((CLSID *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0x47						; VT_CF|VT_ARRAY
					( 
						#array(
								expr: ((CLIPDATA *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )				
					)
					
					#case 8							; VT_BSTR|VT_ARRAY
					( 
						#array(
								expr: ((wchar_t * *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0x16						; VT_INT|VT_ARRAY
					( 
						#array(
								expr: ((int *)$c.pvData)[$i],
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )				
					)
					
					#case 0x17						; VT_UINT|VT_ARRAY		
					( 
						#array(
								expr: ((unsigned int*)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )	
					)			
					
					#default
					(
						#([actual members]: [$e,!])
					)
					#except
					(
						#([actual members]: [$e,!])
					)
			)
			#elif ($c.fFeatures & 0x0100)		; FADF_BSTR 
			(
				#array(expr: ((wchar_t * *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound )	
			)
			#elif ($c.fFeatures & 0x0200)		; FADF_UNKNOWN
			(
				#array(expr: ((IUnknown *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound )	
			)	
			#elif ($c.fFeatures & 0x0400)		; FADF_DISPATCH
			(
				#array(expr: ((IDispatch *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound )	
			)
			#elif ($c.fFeatures & 0x0800)		; FADF_VARIANT
			(
				#array(expr: ((tagVARIANT *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound )	
			)
		)
	)
}

tagPROPVARIANT|tagVARIANT|PROPVARIANT|VARIANT{
	preview(
			#switch ($e.vt)
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;      Base Types                                          ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0 ( #("Empty") )										; VT_EMPTY
				#case 1 ( #("NULL") )										; VT_NULL
				#case 2 ( #("I2 = ", $e.iVal) )								; VT_I2
				#case 3 ( #("I4 = ", $e.lVal) )								; VT_I4
				#case 4 ( #("R4 = ", $e.fltVal) )							; VT_R4
				#case 5 ( #("R8 = ", $e.dblVal) )							; VT_R8
				#case 6 ( #("CY = ", $e.cyVal) )							; VT_CY
				#case 7 ( #("DATE =  ", $e.date) )							; VT_DATE
				#case 8 ( #("BSTR = ", $e.bstrVal) )						; VT_BSTR
				#case 9 ( #("DISPATCH =  ", $e.pdispVal) )					; VT_DISPATCH
				#case 10 ( #("ERROR =  ", $e.scode) )						; VT_ERROR
				#case 0xB ( #("BOOL =  ", $e.boolVal) )						; VT_BOOL
				#case 0xC ( #("VARIANT ") )									; VT_VARIANT
				#case 0xD ( #("UNKNOWN =  ", $e.punkVal) )					; VT_UNKOWN
				#case 0xE ( #("DECIMAL = ", $e.hVal) )						; VT_DECIMAL
				#case 0x10 ( #("I1 =  ", $e.cVal) )							; VT_I1
				#case 0x11 ( #("UI1 =  ", $e.bVal) )							; VT_UI1
				#case 0x12 ( #("UI2 =  ", $e.uiVal) )							; VT_UI2
				#case 0x13 ( #("UI4 =  ", $e.ulVal) )							; VT_UI4
				#case 0x14 ( #("I8 =  ", $e.hVal) )							; VT_I8
				#case 0x15 ( #("UI8 =  ", $e.uhVal) )							; VT_UI8
				#case 0x16 ( #("INT =  ", $e.intVal) )						; VT_INT
				#case 0x17 ( #("UINT = ", $e.uintVal) )						; VT_UINT
				#case 0x18 ( #("VOID ") )										; VT_VOID
				#case 0x19 ( #("HRESULT ") )									; VT_HRESULT
				#case 0x1A ( #("PTR ") )										; VT_PTR
				#case 0x1B ( #("SAFEARRAY ") )								; VT_SAFEARRAY
				#case 0x1C ( #("CARRAY ") )									; VT_CARRAY
				#case 0x1D ( #("USERDEFINED ") )								; VT_USERDEFINED
				#case 0x1E ( #("LPSTR =  ", $e.pszVal) )						; VT_LPSTR
				#case 0x1F ( #("LPWSTR =  ", $e.pwszVal) )					; VT_LPWSTR
				#case 0x24 ( #("RECORD  ") )									; VT_RECORD
				#case 0x26 ( #("UINT_PTR ") )									; VT_UINT_PTR
				#case 0x40 ( #("FILETIME =  ", $e.filetime) )					; VT_FILETIME
				#case 0x42 ( #("STREAM =  ", $e.pStream) )					; VT_STREAM
				#case 0x43 ( #("STORAGE = ", $e.pStorage) )					; VT_STORAGE
				#case 0x44 ( #("STREAMED_OBJECT =  ", $e.pStream) )			; VT_STREAMED_OBJECT
				#case 0x45 ( #("STORED_OBJECT =  ", $e.pStorage) )			; VT_STORED_OBJECT
				#case 0x46 ( #("BLOB_OBJECT = ", $e.blob ) )					; VT_BLOB_OBJECT
				#case 0x47 ( #("CF =  ", $e.pclipdata) )						; VT_CF
				#case 0x48 ( #("CLSID = ", $e.puuid) )						; VT_CLSID
				#case 0x49 ( #("VERSIONED_STREAM = ", $e.pVersionedStream) )	; VT_VERSIONED_STREAM
				
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;   Vector types                                           ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x1002 ( #("vector of I2 = ", $e.cai) )					; VT_I2|VT_VECTOR
				#case 0x1003 ( #("vector of I4 = ", $e.cal) )					; VT_I4|VT_VECTOR
				#case 0x1004 ( #("vector of R4 = ", $e.caflt) )				; VT_R4|VT_VECTOR
				#case 0x1005 ( #("vector of R8 = ", $e.cadbl) )				; VT_R8|VT_VECTOR
				#case 0x1010 ( #("vector of I1 =  ", $e.cac) )				; VT_I1|VT_VECTOR
				#case 0x1011 ( #("vector of UI1 =  ", $e.caub) )				; VT_UI1|VT_VECTOR
				#case 0x1012 ( #("vector of UI2 =  ", $e.caui) )				; VT_UI2|VT_VECTOR
				#case 0x1013 ( #("vector of UI4 =  ", $e.caul) )				; VT_UI4|VT_VECTOR
				#case 0x1014 ( #("vector of I8 =  ", $e.cah) )				; VT_I8|VT_VECTOR
				#case 0x1015 ( #("vector of UI8 =  ", $e.cauh) )				; VT_UI8|VT_VECTOR
				#case 0x101E ( #("vector of LPSTR =  ", $e.calpstr) )			; VT_LPSTR|VT_VECTOR
				#case 0x101F ( #("vector of LPWSTR =  ", $e.calpwstr) )		; VT_LPWSTR|VT_VECTOR
				#case 0x100C ( #("vector of VARIANT ", $e.capropvar) )		; VT_VARIANT|VT_VECTOR
				#case 0x100B ( #("vector of BOOL =  ", $e.cabool) )		    ; VT_BOOL|VT_VECTOR
				#case 0x100A ( #("vector of ERROR =  ", $e.cascode) )			; VT_ERROR|VT_VECTOR
				#case 0x1006 ( #("vector of CY = ", $e.cacy) )				; VT_CY|VT_VECTOR
				#case 0x1007 ( #("vector of DATE =  ", $e.cadate) )			; VT_DATE|VT_VECTOR
				#case 0x1040 ( #("vector of FILETIME =  ", $e.cafiletime) )	; VT_FILETIME|VT_VECTOR
				#case 0x1048 ( #("vector of CLSID = ", $e.cauuid) )			; VT_CLSID|VT_VECTOR
				#case 0x1047 ( #("vector of CF =  ", $e.caclipdata) )			; VT_CF|VT_VECTOR
				#case 0x1008 ( #("vector of BSTR = ", $e.cabstr) )			; VT_BSTR|VT_VECTOR
		
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;   Byref Types                                            ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x4016 ( #("byref of INT =  ", $e.pintVal) )				; VT_INT|VT_BYREF
				#case 0x4017 ( #("byref of UINT = ", $e.puintVal) )				; VT_UINT|VT_BYREF
				#case 0x4002 ( #("byref of I2 = ", $e.piVal) )					; VT_I2|VT_BYREF
				#case 0x4003 ( #("byref of I4 = ", $e.plVal) )					; VT_I4|VT_BYREF
				#case 0x4004 ( #("byref of R4 = ", $e.pfltVal) )					; VT_R4|VT_BYREF
				#case 0x4005 ( #("byref of R8 = ", $e.pdblVal) )					; VT_R8|VT_BYREF
				#case 0x4010 ( #("byref of I1 =  ", $e.pcVal) )					; VT_I1|VT_BYREF
				#case 0x4011 ( #("byref of UI1 =  ", $e.pbVal) )					; VT_UI1|VT_BYREF
				#case 0x4012 ( #("byref of UI2 =  ", $e.puiVal) )				; VT_UI2|VT_BYREF
				#case 0x4013 ( #("byref of UI4 =  ", $e.pulVal) )				; VT_UI4|VT_BYREF
				#case 0x400C ( #("byref of VARIANT ", $e.pvarVal) )				; VT_VARIANT|VT_BYREF
				#case 0x400B ( #("byref of BOOL =  ", $e.pboolVal) )				; VT_BOOL|VT_BYREF
				#case 0x400A ( #("byref of ERROR =  ", $e.pscode) )				; VT_ERROR|VT_BYREF
				#case 0x4006 ( #("byref of CY = ", $e.pcyVal) )					; VT_CY|VT_BYREF
				#case 0x4007 ( #("byref of DATE =  ", $e.pdate) )				; VT_DATE|VT_BYREF
				#case 0x4008 ( #("byref of BSTR = ", $e.pbstrVal) )				; VT_BSTR|VT_BYREF
				#case 0x400E ( #("byref of DECIMAL = ", $e.pdecVal) )			; VT_DECIMAL|VT_BYREF
				#case 0x400D ( #("byref of UNKNOWN =  ", $e.ppunkVal) )			; VT_UNKOWN|VT_BYREF
				#case 0x4009 ( #("byref of DISPATCH =  ", $e.ppdispVal) )		; VT_DISPATCH|VT_BYREF
				#case 0x6000 ( #("byref of ARRAY =  ", $e.pparray) )				; VT_ARRAY|VT_BYREF
							
				#default 
				( 
					#if ($e.vt & 0x2000)
					(
						$e.parray
					)
					#else
					(
						#("Unknown vt type = ", $e.vt) 
					)
				)
	)
	
	
	children(
			#(vt: $e.vt, 
			#switch ($e.vt)
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;      Base Types                                          ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x2 ( #(I2  : $e.iVal) )								; VT_I2
				#case 0x3 ( #(I4  : $e.lVal) )								; VT_I4
				#case 0x4 ( #(R4  : $e.fltVal) )								; VT_R4
				#case 0x5 ( #(R8  : $e.dblVal) )								; VT_R8
				#case 0x6 ( #(CY  : $e.cyVal) )								; VT_CY
				#case 0x7 ( #(DATE   : $e.date) )								; VT_DATE
				#case 0x8 ( #(BSTR  : $e.bstrVal) )							; VT_BSTR
				#case 0x9 ( #(DISPATCH   : $e.pdispVal) )						; VT_DISPATCH
				#case 0xA ( #(ERROR   : $e.scode) )							; VT_ERROR
				#case 0xB ( #(BOOL   : $e.boolVal) )							; VT_BOOL
				#case 0xD ( #(UNKNOWN   : $e.punkVal) )						; VT_UNKOWN
				#case 0xE ( #(DECIMAL  : $e.hVal) )							; VT_DECIMAL
				#case 0x10 ( #(I1   : $e.cVal) )								; VT_I1
				#case 0x11 ( #(UI1   : $e.bVal) )								; VT_UI1
				#case 0x12 ( #(UI2   : $e.uiVal) )							; VT_UI2
				#case 0x13 ( #(UI4   : $e.ulVal) )							; VT_UI4
				#case 0x14 ( #(I8   : $e.hVal) )								; VT_I8
				#case 0x15 ( #(UI8   : $e.uhVal) )							; VT_UI8
				#case 0x16 ( #(INT   : $e.intVal) )							; VT_INT
				#case 0x17 ( #(UINT  : $e.uintVal) )							; VT_UINT
				#case 0x1E ( #(LPSTR   : $e.pszVal) )							; VT_LPSTR
				#case 0x1F ( #(LPWSTR   : $e.pwszVal) )						; VT_LPWSTR
				#case 0x40 ( #(FILETIME   : $e.filetime) )					; VT_FILETIME
				#case 0x42 ( #(STREAM   : $e.pStream) )						; VT_STREAM
				#case 0x43 ( #(STORAGE  : $e.pStorage) )						; VT_STORAGE
				#case 0x44 ( #(STREAMED_OBJECT   : $e.pStream) )				; VT_STREAMED_OBJECT
				#case 0x45 ( #(STORED_OBJECT   : $e.pStorage) )				; VT_STORED_OBJECT
				#case 0x46 ( #(BLOB_OBJECT  : $e.blob ) )						; VT_BLOB_OBJECT
				#case 0x47 ( #(CF   : $e.pclipdata) )							; VT_CF
				#case 0x48 ( #(CLSID  : $e.puuid) )							; VT_CLSID
				#case 0x49 ( #(VERSIONED_STREAM  : $e.pVersionedStream) )		; VT_VERSIONED_STREAM
				
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;   Vector types                                           ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x1002 ( #(vector of I2  : $e.cai) )					; VT_I2|VT_VECTOR
				#case 0x1003 ( #(vector of I4  : $e.cal) )					; VT_I4|VT_VECTOR
				#case 0x1004 ( #(vector of R4  : $e.caflt) )					; VT_R4|VT_VECTOR
				#case 0x1005 ( #(vector of R8  : $e.cadbl) )					; VT_R8|VT_VECTOR
				#case 0x1010 ( #(vector of I1   : $e.cac) )					; VT_I1|VT_VECTOR
				#case 0x1011 ( #(vector of UI1   : $e.caub) )					; VT_UI1|VT_VECTOR
				#case 0x1012 ( #(vector of UI2   : $e.caui) )					; VT_UI2|VT_VECTOR
				#case 0x1013 ( #(vector of UI4   : $e.caul) )					; VT_UI4|VT_VECTOR
				#case 0x1014 ( #(vector of I8   : $e.cah) )					; VT_I8|VT_VECTOR
				#case 0x1015 ( #(vector of UI8   : $e.cauh) )					; VT_UI8|VT_VECTOR
				#case 0x101E ( #(vector of LPSTR   : $e.calpstr) )			; VT_LPSTR|VT_VECTOR
				#case 0x101F ( #(vector of LPWSTR   : $e.calpwstr) )			; VT_LPWSTR|VT_VECTOR
				#case 0x100C ( #(vector of VARIANT : $e.capropvar) )			; VT_VARIANT|VT_VECTOR
				#case 0x100B ( #(vector of BOOL   : $e.cabool) )				; VT_BOOL|VT_VECTOR
				#case 0x100A ( #(vector of ERROR   : $e.cascode) )			; VT_ERROR|VT_VECTOR
				#case 0x1006 ( #(vector of CY  : $e.cacy) )					; VT_CY|VT_VECTOR
				#case 0x1007 ( #(vector of DATE   : $e.cadate) )				; VT_DATE|VT_VECTOR
				#case 0x1040 ( #(vector of FILETIME   : $e.cafiletime) )		; VT_FILETIME|VT_VECTOR
				#case 0x1048 ( #(vector of CLSID  : $e.cauuid) )				; VT_CLSID|VT_VECTOR
				#case 0x1047 ( #(vector of CF   : $e.caclipdata) )			; VT_CF|VT_VECTOR
				#case 0x1008 ( #(vector of BSTR  : $e.cabstr) )				; VT_BSTR|VT_VECTOR

				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;   Byref Types                                            ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x4016 ( #(byref of INT   : $e.pintVal) )				; VT_INT|VT_BYREF
				#case 0x4017 ( #(byref of UINT  : $e.puintVal) )				; VT_UINT|VT_BYREF
				#case 0x4002 ( #(byref of I2  : $e.piVal) )					; VT_I2|VT_BYREF
				#case 0x4003 ( #(byref of I4  : $e.plVal) )					; VT_I4|VT_BYREF
				#case 0x4004 ( #(byref of R4  : $e.pfltVal) )				; VT_R4|VT_BYREF
				#case 0x4005 ( #(byref of R8  : $e.pdblVal) )				; VT_R8|VT_BYREF
				#case 0x4010 ( #(byref of I1   : $e.pcVal) )					; VT_I1|VT_BYREF
				#case 0x4011 ( #(byref of UI1   : $e.pbVal) )				; VT_UI1|VT_BYREF
				#case 0x4012 ( #(byref of UI2   : $e.puiVal) )				; VT_UI2|VT_BYREF
				#case 0x4013 ( #(byref of UI4   : $e.pulVal) )				; VT_UI4|VT_BYREF
				#case 0x400C ( #(byref of VARIANT : $e.pvarVal) )			; VT_VARIANT|VT_BYREF
				#case 0x400B ( #(byref of BOOL   : $e.pboolVal) )			; VT_BOOL|VT_BYREF
				#case 0x400A ( #(byref of ERROR   : $e.pscode) )				; VT_ERROR|VT_BYREF
				#case 0x4006 ( #(byref of CY  : $e.pcyVal) )					; VT_CY|VT_BYREF
				#case 0x4007 ( #(byref of DATE   : $e.pdate) )				; VT_DATE|VT_BYREF
				#case 0x4008 ( #(byref of BSTR  : $e.pbstrVal) )				; VT_BSTR|VT_BYREF
				#case 0x400E ( #(byref of DECIMAL  : $e.pdecVal) )			; VT_DECIMAL|VT_BYREF
				#case 0x400D ( #(byref of UNKNOWN   : $e.ppunkVal) )			; VT_UNKOWN|VT_BYREF
				#case 0x4009 ( #(byref of DISPATCH   : $e.ppdispVal) )		; VT_DISPATCH|VT_BYREF
				#case 0x6000 ( #(byref of ARRAY   : $e.pparray) )			; VT_ARRAY|VT_BYREF
				
				; the following are either empty or invalid vt values for a variant
				; #case 0 ( #(Empty :) )										; VT_EMPTY
				; #case 0x1 ( #(NULL :) )										; VT_NULL
				; #case 0xC ( #(VARIANT :) )									; VT_VARIANT
				; #case 0x18 ( #(VOID :) )										; VT_VOID
				; #case 0x19 ( #(HRESULT :) )									; VT_HRESULT
				; #case 0x1A ( #(PTR :) )										; VT_PTR
				; #case 0x1B ( #(SAFEARRAY :) )									; VT_SAFEARRAY
				; #case 0x1C ( #(CARRAY :) )									; VT_CARRAY
				; #case 0x1D ( #(USERDEFINED :) )								; VT_USERDEFINED
				; #case 0x24 ( #(RECORD  :) )									; VT_RECORD
				; #case 0x26 ( #(UINT_PTR :) )									; VT_UINT_PTR
							
				#default 
				( 
					#if ($e.vt & 0x2000 )
					(
						#(safearray: $e.parray)
					)
					#else
					(
						#(
							[raw members]: [$e,!]	; unformatted data members
						)
					)
				)							
				#except 
				( 
					#(
						[raw members]: [$e,!]	; unformatted data members
					)
				)							
	))
}

;QT_DEBUG_START (Qt Visual Studio Add-in v1.1.10)
; Nokia Qt 4.x visualizers -----------------------------------------[ start ]--
;------------------------------------------------------------------------------
; Feel free to modify these visualizers to suit yours needs! But please let us
; know about the changes you make, so we continuously improve the visualizers.

QString{
    preview         ([$e.d->data,su])
    stringview      ([$e.d->data,sub])
    children
    (
        #(
            d: $c.d,
            [size]: $c.d->size,
            [referenced]: $c.d->ref._q_value
        )
    )
}

QByteArray{
    preview         ([$e.d->data,s])
    stringview      ([$e.d->data,sb])
    children
    (
        #(
            d: $c.d,
            [size]: $c.d->size,
            [referenced]: $c.d->ref._q_value
        )
    )

}

QUrl{
	preview
	(
		#if ($e.d.stateFlags == 0) (
			$e.d
		) #else (
			#( $e.d->scheme, $e.d->host, $e.d->path )
		)
	)
	children
	(
		#(
			scheme: $c.d->scheme,
			host: $c.d->host,
			path: $c.d->path,
			username: $c.d->userName,
			password: $c.d->password,
			encodedOriginal: $c.d->encodedOriginal,
			query: $c.d->query,
			fragment: $c.d->fragment
		)
	)
}

QFileInfo{
    preview
    (
        #(
            "private=", $c.d_ptr
        )
    )
}

;------------------------------------------------------------------------------
; QStringList
;------------------------------------------------------------------------------
QStringList{
    preview
    (
        #if (($c.d->end - $c.d->begin) <= 10) (
            #(
                "[", $c.d->end - $c.d->begin, "](",
                #array
                (
                    expr: (QString)(($c.d->array + $c.d->begin)[$i]),
                    size: $c.d->end-$c.d->begin
                ), ")"
            )
        ) #else (
            #(
                "[", $c.d->end - $c.d->begin, "](",
                #array
                (
                    expr: (QString)(($c.d->array + $c.d->begin)[$i]),
                    size: 10
                ), ", ...)"
            )
        )
    )
}

;------------------------------------------------------------------------------
; QList, QQueue
;------------------------------------------------------------------------------
QList<*>|QQueue<*>{
    preview
    (
        #if (($c.d->end - $c.d->begin) <= 10) (
            #(
                "[", $c.d->end - $c.d->begin, "](",
                #array
                (
                    expr: ($T1)(($c.d->array + $c.d->begin)[$i]),
                    size: $c.d->end-$c.d->begin
                ), ")"
            )
        ) #else (
            #(
                "[", $c.d->end - $c.d->begin, "](",
                #array
                (
                    expr: ($T1)(($c.d->array + $c.d->begin)[$i]),
                    size: 10
                ), ", ...)"
            )
        )
    )

    children
    (
        #array (
            expr: ($T1)(($c.d->array + $c.d->begin)[$i]),
            size: $c.d->end - $c.d->begin
        )
    )
}

;------------------------------------------------------------------------------
; QList::iterator, QQueue::iterator
;------------------------------------------------------------------------------
QList<*>::iterator|QList<*>::const_iterator|QQueue<*>::iterator|QQueue<*>::const_iterator{
    preview
    (
        #(
            ($T1)$c.i->v
        )
    )

    children
    (
        #(
            ptr: ($T1)$c.i->v
        )
    )
}

;------------------------------------------------------------------------------
; QListIterator
;------------------------------------------------------------------------------
QListIterator<*>|QMutableListIterator<*> {
    preview
    (
        #(
            ($T1)$c.i.i->v
        )
    )

    children
    (
        #(
            ptr: ($T1)$c.i.i->v
        )
    )
}

;------------------------------------------------------------------------------
; QLinkedList
;------------------------------------------------------------------------------
QLinkedList<*>{
    preview
    (
        #if ($e.d->size >= 10) (
            #(
                "[", $e.d->size, "](",
                #list
                (
                    head: $c.d->n,
                    size: 10,
                    next: n
                ) : ( (*(QLinkedListNode<$T1>*)&$e).t ), ", ...)"
            )
        ) #else (
            #(
                "[", $e.d->size, "](",
                #list
                (
                    head: $c.d->n,
                    size: $c.d->size,
                    next: n
                ) : ( (*(QLinkedListNode<$T1>*)&$e).t ), ")"
            )
        )
    )

    children
    (
        #(
            #list
            (
                head: $c.d->n,
                size: $c.d->size,
                next: n
            ) : (*(QLinkedListNode<$T1>*)&$e).t
        )
    )
}

;------------------------------------------------------------------------------
; QLinkedList::iterator
;------------------------------------------------------------------------------
QLinkedList<*>::iterator|QLinkedList<*>::const_iterator{
    preview
    (
        #(
            $e.i->t
        )
    )

    children
    (
        #(
            ptr: $e.i->t
        )
    )
}

;------------------------------------------------------------------------------
; QVector, QStack
;
; By default, this visualizer supports only Qt 4.6.x. If you're going to use
; Qt 4.5.x code, then you may want to replace all expr lines with this:
;    expr: (((size_t)($c.d) + (size_t)(sizeof(QVectorData)) ))[$i],
;
; This will allow this visualizer to display Qt 4.5.x and Qt 4.6.x QVector
; objects. But be aware of some limitations. For example enum types can't be
; displayed properly this way.
;
; Qt 4.5.x:
;     QVector::d is QVectorTypedData<T>
;     QVector::p is QVectorData
;     expr: $c.d->array[$i]
;
; Qt 4.6.x:
;     QVector::d is QVectorData
;     QVector::p is QVectorTypedData<T>
;     expr: $c.p->array[$i]
;
;------------------------------------------------------------------------------
QVector<*>|*::QVector<*>|QStack<*>|*::QStack<*>{
    preview
    (
        #if ($c.d->size <= 10) (
            #(
                "[", $c.d->size, "](",
                #array
                (
                    expr: $c.p->array[$i],
                    size: $c.d->size
                ), ")"
            )
        ) #else (
            #(
                "[", $c.d->size, "](",
                #array
                (
                    expr: $c.p->array[$i],
                    size: 10
                ), ", ...)"
            )
        )
    )
    children
    (
        #array
        (
            expr: $c.p->array[$i],
            size: $c.d->size
        )
    )
}

;------------------------------------------------------------------------------
; QMap
;------------------------------------------------------------------------------
QMapNode<*,*>{
    preview
    (
        #(
            "(",
            $e.key,
            "; ",
            $e.value,
            ")"
        )
    )

    children
    (
        #(
            key: $e.key,
            value: $e.value
        )
    )
}

QMap<*>{
    children
    (
        #(
            raw data: [$c,!],
            #tree
            (
                head : $c.d->forward[0],
                skip : $c.d,
                size : $c.d->size,
                left : backward,
                right : forward
            ) : ( (QMapNode<$T1>*)((char*)&$e - (sizeof(QMapPayloadNode<$T1>) - sizeof(QMapData::Node*))) )
        )
    )

    preview
    (
        #(
            "[",
            $e.d->size,
            "](",
                #tree
                (
                    head : $c.d->forward[0],
                    size : $c.d->size,
                    left : backward,
                    right : forward
                ) : $e,
            ")"
        )
    )
}

;------------------------------------------------------------------------------
; QHash
;------------------------------------------------------------------------------
QHash<*>{
    preview
    (
        #(
            "[", $e.d->size, "] (...)"
        )
    )
    children
    (
        #if ($e.d->size <= 255) (
            #(
                #array (
                    expr: (QHashNode<$T1>*)$c.d->buckets[$i],
                    size: $c.d->numBuckets
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e
                )
            )
        ) #else (
            #(
                #array (
                    expr: (QHashNode<$T1>*)$c.d->buckets[$i],
                    size: 255
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e
                )
            )
        )
    )
}

*::QHash<*>{
    preview
    (
        #(
             "[", $e.d->size, "] (...)"
        )
    )
    children
    (
        #if ($e.d->size <= 255) (
            #(
                #array (
                    expr: ($T1::QHashNode<$T2> *)$c.d->buckets[$i],
                    size: $c.d->numBuckets
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e
                )
            )
        ) #else (
            #(
                #array (
                    expr: ($T1::QHashNode<$T2> *)$c.d->buckets[$i],
                    size: 255
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e
                )
            )
        )
    )
}

;------------------------------------------------------------------------------
; QMultiHash
;------------------------------------------------------------------------------
QMultiHash<*>{
    preview
    (
        (*(QHash<$T1>*)(&$c))
    )
}

*::QMultiHash<*>{
    preview
    (
        (*($T1::QHash<$T2>*)(&$c))
    )
}

;------------------------------------------------------------------------------
; QHash::iterator
;------------------------------------------------------------------------------
QHash<*>::iterator{
    preview
    (
        #(
            "(", ((QHashNode<$T1>*)($c.i))->key, ", ", ((QHashNode<$T1>*)($c.i))->value, ")"
        )
    )
    children
    (
        #(
            key: ((QHashNode<$T1>*)($c.i))->key,
            value: ((QHashNode<$T1>*)($c.i))->value
        )
    )
}

*::QHash<*>::iterator{
    preview
    (
        #(
            "(", (($T1::QHashNode<$T2>*)($c.i))->key, ", ", (($T1::QHashNode<$T2>*)($c.i))->key, ")"
        )
    )
    children
    (
        #(
            key: (($T1::QHashNode<$T2>*)($c.i))->key,
            value: (($T1::QHashNode<$T2>*)($c.i))->value
        )
    )
}

;------------------------------------------------------------------------------
; QHashIterator
;------------------------------------------------------------------------------
QHashIterator<*>{
    preview
    (
        #(
            "(", ((QHashNode<$T1>*)((($c).i).i))->key, ", ", ((QHashNode<$T1>*)((($c).i).i))->key, ")"
        )
    )
    children
    (
        #(
            key: ((QHashNode<$T1>*)((($c).i).i))->key,
            value: ((QHashNode<$T1>*)((($c).i).i))->value
        )
    )
}

*::QHashIterator<*>{
    preview
    (
        #(
            "(", (($T1::QHashNode<$T2>*)((($c).i).i))->key, ", ", (($T1::QHashNode<$T2>*)((($c).i).i))->key, ")"
        )
    )
    children
    (
        #(
            key: (($T1::QHashNode<$T2>*)((($c).i).i))->key,
            value: (($T1::QHashNode<$T2>*)((($c).i).i))->value
        )
    )
}

;------------------------------------------------------------------------------
; QHashNode
;------------------------------------------------------------------------------
QHashNode<*>|*::QHashNode<*>{
    preview
    (
        #(
            "(key = ", $c.key,"; value = ", $c.value, ")"
        )
    )
    children
    (
        #(
            key: $c.key,
            value: $c.value
        )
    )
}

;------------------------------------------------------------------------------
; QSet
;------------------------------------------------------------------------------
QSet<*>{
    preview
    (
        #(
             "[", $e.q_hash.d->size, "] (...)"
        )
    )
    children
    (
        #if ($e.q_hash.d->size <= 255) (
            #(
                #array (
                    expr: (QHashNode<$T1,QHashDummyValue> *)$c.q_hash.d->buckets[$i],
                    size: $c.q_hash.d->numBuckets
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e.key
                )
            )
        ) #else (
            #(
                #array (
                    expr: (QHashNode<$T1,QHashDummyValue> *)$c.q_hash.d->buckets[$i],
                    size: 255
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e.key
                )
            )
        )
    )
}

*::QSet<*>{
    preview
    (
        #(
             "[", $e.q_hash.d->size, "] (...)"
        )
    )
    children
    (
        #if ($e.q_hash.d->size <= 255) (
            #(
                #array (
                    expr: ($T1::QHashNode<$T2,QHashDummyValue> *)$c.q_hash.d->buckets[$i],
                    size: $c.q_hash.d->numBuckets
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e.key
                )
            )
        ) #else (
            #(
                #array (
                    expr: ($T1::QHashNode<$T2,QHashDummyValue> *)$c.q_hash.d->buckets[$i],
                    size: 255
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e.key
                )
            )
        )
    )
}

;------------------------------------------------------------------------------
; QPolygon
;------------------------------------------------------------------------------
QPolygon{
    preview
    (
        #(
             "[", ((QVector<QPoint>*)(&$c))->d->size, "] (...)"
        )
    )
    children
    (
        #(
            #array
            (
                expr: ((QPoint*)(((void*)$c.d) + sizeof(QVectorData)))[$i],
                size: ((QVector<QPoint>*)(&$c))->d->size
            )
        )
    )
}
*::QPolygon{
    preview
    (
        #(
             "[", (($T1::QVector<$T1::QPoint>*)(&$c))->d->size, "] (...)"
        )
    )
    children
    (
        #(
            #array
            (
                expr: (($T1::QPoint*)(((void*)$c.d) + sizeof(QVectorData)))[$i],
                size: (($T1::QVector<$T1::QPoint>*)(&$c))->d->size
            )
        )
    )
}

;------------------------------------------------------------------------------
; QPolygonF
;------------------------------------------------------------------------------
QPolygonF{
    preview
    (
        #(
             "[", ((QVector<QPointF>*)(&$c))->d->size, "] (...)"
        )
    )
    children
    (
        #(
            #array
            (
                expr: ((QVector<QPointF>*)(&$c))->p->array[$i],
                size: ((QVector<QPointF>*)(&$c))->d->size
            )
        )
    )
}

*::QPolygonF{
    preview
    (
        #(
             "[", (($T1::QVector<$T1::QPointF>*)(&$c))->d->size, "] (...)"
        )
    )
    children
    (
        #(
            #array
            (
                expr: (($T1::QVector<$T1::QPointF>*)(&$c))->p->array[$i],
                size: (($T1::QVector<$T1::QPointF>*)(&$c))->d->size
            )
        )
    )
}

;------------------------------------------------------------------------------

; The debugger has trouble accessing the QDirPrivate member, so we have to cheat.
; The class looks like this :
;     class QDirPrivate {
;         QDir* q_ptr;
;     #ifdef QT3_SUPPORT
;         QChar filterSepChar;
;         bool matchAllDirs;
;     #endif
;         Data* data;
;         class Data {
;             QAtomic ref;
;             QString path;
;         };
;     };
; This visualizer assumes the following :
;     Qt built with QT3_SUPPORT
;     offsetof(QDirPrivate, data) == 8
;     offsetof(QDirPrivate::Data, path) == 4
QDir{
	preview(
		#(
			*(QString*)((*(char**)(((char*)$e.d_ptr) + 8)) + 4)
		)
	)
}

;------------------------------------------------------------------------------

; Converting from julian day to day/month/year usually involves several intermediate variables.
; Unfortunately, in a vizualizer we can't use any, so we must do it in a single (scarry) expression.
; Not elegant, but works pretty well !
QDate{
	preview(
		#if ($e.jd == 0) (
			#( "Null Date" )
		)
		#else (
			#(
				(((((($e.jd+32044)%146097)-(((($e.jd+32044)%146097)/36524+1)*3/4)*36524)%1461)-(((((($e.jd+32044)%146097)-(((($e.jd+32044)%146097)/36524+1)*3/4)*36524)%1461)/365+1)*3/4)*365)-(((((((($e.jd+32044)%146097)-(((($e.jd+32044)%146097)/36524+1)*3/4)*36524)%1461)-(((((($e.jd+32044)%146097)-(((($e.jd+32044)%146097)/36524+1)*3/4)*36524)%1461)/365+1)*3/4)*365)*5+308)/153-2)+4)*153/5+122)+1,
				"/",
				(((((((($e.jd+32044)%146097)-(((($e.jd+32044)%146097)/36524+1)*3/4)*36524)%1461)-(((((($e.jd+32044)%146097)-(((($e.jd+32044)%146097)/36524+1)*3/4)*36524)%1461)/365+1)*3/4)*365)*5+308)/153-2)+2)%12+1,
				"/",
				(($e.jd+32044)/146097)*400+(((($e.jd+32044)%146097)/36524+1)*3/4)*100+(((($e.jd+32044)%146097)-(((($e.jd+32044)%146097)/36524+1)*3/4)*36524)/1461)*4+(((((($e.jd+32044)%146097)-(((($e.jd+32044)%146097)/36524+1)*3/4)*36524)%1461)/365+1)*3/4)-4800+(((((((($e.jd+32044)%146097)-(((($e.jd+32044)%146097)/36524+1)*3/4)*36524)%1461)-(((((($e.jd+32044)%146097)-(((($e.jd+32044)%146097)/36524+1)*3/4)*36524)%1461)/365+1)*3/4)*365)*5+308)/153-2)+2)/12
			)
		)
	)
}


;------------------------------------------------------------------------------

; #if (1) (":") is a hack needed because the debugger has trouble displaying colons.
QTime{
	preview(
		#if ($e.mds < 0) (
			#( "Null Time" )
		)
		#else (
			#(
				#if ($e.mds / 3600000 < 10)      ("0"), $e.mds / 3600000,
				#if (1) (":"),
				#if (($e.mds / 60000) % 60 < 10) ("0"), ($e.mds / 60000) % 60,
				#if (1) (":"),
				#if (($e.mds / 1000) % 60 < 10)  ("0"), [($e.mds % 60000) / 1000.0,g]
			)
		)
	)
}

;------------------------------------------------------------------------------

; The debugger has trouble accessing QDateTimePrivate, so we have to cheat.
; The class looks like this (Qt 4.5) :
;     class QDateTimePrivate {
;         QAtomicInt ref;
;         QDate date;
;         QTime time;
;         ...
;     };
; This visualizer assumes the class members are tighly packed.
QDateTime{
	preview(
		#(
			*(QDate*)(((char*)$e.d) + sizeof(QAtomicInt)),
			" ",
			*(QTime*)(((char*)$e.d) + sizeof(QAtomicInt) + sizeof(QDate))
		)
	)
}

;------------------------------------------------------------------------------

; NB : "$e.d.data.i" doesn't seem to work, so we have to use hacks such as "*(int*)&$e.d.data"
QVariant{
	preview(
		#switch ($e.d.type)
			#case 0  ( #( "Invalid" ) )
			#case 1  ( #( *(bool*)&$e.d.data ) )
			#case 2  ( #( *(int*)&$e.d.data ) )
			#case 3  ( #( *(unsigned*)&$e.d.data,"U" ) )
			#case 4  ( #( *(qlonglong*)&$e.d.data,"L" ) )
			#case 5  ( #( *(qulonglong*)&$e.d.data,"UL" ) )
			#case 6  ( #( [*(double*)&$e.d.data,g] ) )
			#case 7  ( #( *(QChar*)&$e.d.data ) )
			#case 8  ( #( *(QMap<QString,QVariant>*)&$e.d.data ) )
			#case 9  ( #( *(QList<QVariant>*)&$e.d.data ) )
			#case 10 ( #( [((QString*)&$e.d.data)->d->data,su] ) )
			#case 11 ( #( *(QStringList*)&$e.d.data ) )
			#case 12 ( #( *(QByteArray*)&$e.d.data ) )
			#case 14 ( #( *(QDate*)&$e.d.data ) )
			#case 15 ( #( *(QTime*)&$e.d.data ) )
			#case 16 ( #( *(QDateTime*)&$e.d.data) )
			#case 28 ( #( *(QHash<QString,QVariant>*)&$e.d.data ) )
			#default ( #( "(QVariant : Type ", $e.d.type, ")" ) )
	)
}

;------------------------------------------------------------------------------
; Nokia Qt 4.x visualizers -------------------------------------------[ end ]--
;QT_DEBUG_END


; This section lets you define your own errors for the HRESULT display.
; You need to list the error code in unsigned decimal, followed by the message.
; Changes will take effect the next time you redisplay the variable.
[hresult]
;1234=my custom error code
